---
title: "BLDC 모터 제어의 정석: FOC(자계 지향 제어)의 원리와 역사"
date: 2026-01-09
excerpt_separator: "<!--more-->"
categories:
  - robot
tags:
  - robot

toc : true
toc_sticky : true
---


로봇 개발을 진행하며 모터 드라이버와 제어 알고리즘을 공부하다가 알게 된 **FOC(Field Oriented Control)**와 하드웨어 제어 구조에 대해 정리해 본다. 처음에는 전류 센서가 전압을 승압해 주는 것 아닌가 하는 오해에서 시작했지만, 공부를 거듭하며 전류와 전압의 관계, 그리고 제어의 깊은 역사까지 파고들게 되었다.

## 1. 하드웨어의 오해와 진실: 센서 vs 드라이버

BLDC 모터 회로를 처음 분석할 때 가장 헷갈렸던 부분은 **전류 센서**와 **게이트 드라이버**의 역할이었다.

### 1.1 전류 센서는 '관찰자'일 뿐이다
회로도에서 전류 센서(Current Sensor)가 모터로 가는 길목에 있어서 "이 녀석이 전압을 뻥튀기(승압)해서 모터로 보내나?"라고 생각했다. 하지만 이는 정반대였다.

* **실제 역할:** 모터로 흘러가는 전류를 몰래 지켜보고(Sensing), "지금 1.5A 흐르고 있어"라고 MCU에게 알려주는 **피드백(Feedback)** 장치다.
* **신호 흐름:** `배터리` → `FET(스위치)` → `전류 센서` → `모터`

### 1.2 승압(Boosting)은 누가 하는가?
실제로 전압을 높여주는(Bootstrapping) 역할은 **게이트 드라이버(Gate Driver)**와 그 주변의 **커패시터(Capacitor)**가 담당한다.
* **High-Side FET 구동:** N-Ch MOSFET을 켜기 위해서는 모터 전압보다 더 높은 전압이 필요하다.
* **부트스트랩(Bootstrap):** 커패시터에 전기를 충전해 뒀다가, 필요할 때 전압을 얹어서(승압) 게이트를 열어준다.

<div class="mermaid">
graph LR
    MCU["MCU (Brain)"] -->|"PWM Signal"| GD["Gate Driver"]
    GD -->|"High Voltage"| FET["MOSFET Bridge"]
    FET -->|"High Current"| CS["Current Sensor"]
    CS -->|"Feedback Signal"| MCU
    CS -->|"Drive Current"| Motor(("BLDC Motor"))
    
    style MCU fill:#f9f,stroke:#333,stroke-width:2px
    style Motor fill:#ff9,stroke:#333,stroke-width:2px
</div>

---

## 2. 모터 제어의 혁명: FOC (자계 지향 제어)

BLDC 모터는 3상(U, V, W) 교류를 사용하기 때문에 제어가 까다롭다. 단순히 전류를 흘리면 이게 회전력(토크)이 되는지, 그냥 자석만 누르는 힘(열)이 되는지 알기 어렵다. 이를 해결한 것이 **FOC**다.

### 2.1 FOC의 역사
이 천재적인 방법은 1970년대 초반에 등장했다.
* **창시자:** 독일 지멘스(Siemens)의 엔지니어 **펠릭스 블라쉬케(Felix Blaschke)** (1971년)
* **핵심 아이디어:** "복잡한 AC 모터를 수학적으로 변환해서, 제어하기 쉬운 DC 모터처럼 다루자!"
* **기반 이론:** 1929년 R.H. Park가 발표한 '파크 변환(Park Transformation)'을 실시간 제어에 적용했다.

### 2.2 회전문의 비유 (토크 vs 자속)
모터를 **회전문**이라고 생각하면 이해가 쉽다.
1.  **토크($I_q$):** 회전문의 손잡이를 잡고 결대로(수직으로) 미는 힘. → **문이 잘 돌아간다.**
2.  **자속($I_d$):** 회전문의 중심 기둥 쪽으로 꾹 누르는 힘. → **문은 안 돌고 힘만 든다.**

FOC의 목표는 수학적 계산을 통해 **$I_d$(낭비)를 0으로 만들고, $I_q$(회전력)만 제어**하는 것이다.

---

## 3. 마법의 수학: 좌표 변환 (Coordinate Transformation)

어떻게 3개의 전선(3상)을 2개의 직류 값($I_d, I_q$)으로 바꿀까? 여기서 **'회전목마의 비유'**가 등장한다.

### 3.1 정지 좌표계 vs 회전 좌표계
* **3상 좌표계 (현실):** 밖에서 회전목마를 보면 말이 정신없이 지나간다. (전류값이 계속 변하는 AC 파형)
* **회전 좌표계 ($d-q$축):** 내가 **회전목마에 올라타서** 말(자석)과 같이 돌면서 쳐다본다.
    * 내 눈에는 말이 **멈춰 있는 것처럼** 보인다.
    * 즉, 변하던 전류값이 **일정한 직류(DC) 값**으로 보인다!

### 3.2 핵심 수식 (Park 변환 & 역변환)
MCU는 내부적으로 1초에 수만 번씩 아래 계산을 수행하여, 우리가 원하는 전압을 만들어낸다.

**[Inverse Park Transform]**: 회전 좌표계($d,q$)의 값을 정지 좌표계($\alpha, \beta$)로 변환하여 전압 지령치를 만드는 과정.

$$
\begin{cases}
V_\alpha = V_d \cos\theta - V_q \sin\theta \\
V_\beta = V_d \sin\theta + V_q \cos\theta
\end{cases}
$$

여기서 $\theta$는 현재 모터(회전자)의 각도다. 즉, 각도를 모르면 FOC를 할 수 없다.

---

## 4. 제어 루프의 구조: 캐스케이드(Cascade) 제어

로봇의 관절을 움직일 때, "30도로 움직여!"라고 명령하면 내부에서는 3단계의 하청 구조(?)가 작동한다. 이것이 **캐스케이드 제어**다.

<div class="mermaid">
flowchart LR
    Target["목표 위치"] --> P_Control["위치 제어기"]
    P_Control -->|"목표 속도"| V_Control["속도 제어기"]
    V_Control -->|"목표 전류 Iq"| C_Control["전류 제어기(FOC)"]
    C_Control -->|"전압 PWM"| Motor
    
    subgraph FeedbackLoop ["Feedback Loop"]
    Motor -.->|"현재 위치/속도"| P_Control
    Motor -.->|"현재 전류"| C_Control
    end
</div>

1.  **위치 제어:** "30도로 가려면 속도를 10rpm으로 해!"
2.  **속도 제어:** "10rpm을 내려면 전류(토크)를 0.5A 줘!"
3.  **전류 제어:** "0.5A를 흐르게 하려면 전압을 3V로 쏴!"

### 4.1 전류는 전압으로 제어한다
가장 중요한 깨달음은 **"우리는 전류를 직접 조종할 수 없다"**는 것이다.
* 우리는 **전압(수도꼭지)**만 조절할 수 있다.
* 전압을 조절하면 옴의 법칙($I=V/R$)과 모터 특성에 따라 **전류(물)**가 흐르게 된다.
* 배터리는 '최대 공급 능력(Max Current)'이 정해져 있을 뿐, 모터가 요구하는 만큼(전압에 비례해서) 전류가 나간다. 따라서 MCU는 과전류가 흐르지 않도록 **전압을 제한(Clamping)**하는 역할을 한다.

---

## 5. 정리하며

단순히 모터를 돌리는 것인 줄 알았는데, 그 안에는 **좌표계 변환이라는 수학**과, **물리적인 전자기학**, 그리고 **피드백 제어 이론**이 정교하게 맞물려 있었다. 

과거에는 슈퍼컴퓨터로 하던 이 복잡한 계산을 이제는 손톱만한 MCU가 척척 해내는 시대다. 이 작은 칩 안에서 일어나는 수학적 마법 덕분에 로봇이 부드럽게 움직일 수 있다는 사실이 새삼 놀랍다.

---

## 6. 번외: 센서가 없어도 제어가 된다고? (Sensorless)

BLDC 모터 제어를 공부하다 보면 "엔코더(위치 센서) 없이도 제어가 가능하다"는 이야기를 듣게 된다. 이를 **센서리스(Sensorless) 제어**라고 한다.

### 6.1 원리: 역기전력(Back-EMF)
모터가 회전하면 코일 내부에서 발전기처럼 전기가 만들어지는데 이를 '역기전력'이라고 한다. MCU가 이 전압을 읽어서 "아, 지금 모터가 이쯤 돌고 있구나"라고 위치를 역추적하는 기술이다. 주로 드론(ESC)이나 팬(Fan)에 많이 쓰인다.

### 6.2 로봇 팔에는 왜 안 쓸까?
"선도 줄어들고 좋은데 왜 로봇 손가락에는 꼭 엔코더를 달까?"
치명적인 단점이 있기 때문이다.

1.  **죽은 자는 말이 없다 (초기 기동 불가):** 역기전력은 **모터가 돌아야만** 나온다. 멈춰 있을 때는 위치를 전혀 알 수 없다. 그래서 처음 출발할 때 모터를 억지로 떨거나 강제로 돌려야 하는데, 로봇 팔이 갑자기 제멋대로 움직이면 곤란하다.
2.  **저속 제어의 한계:** 아주 천천히 움직이거나, 물건을 잡고 **가만히 버티는(Holding) 상황**에서는 역기전력이 너무 작아서 위치를 놓친다.

따라서 정밀한 위치 제어가 필요한 로봇 분야에서는 센서리스보다는 **엔코더를 장착한 FOC 제어**가 필수적이다.

> **참고:** 이 글은 학습 과정에서 이해한 내용을 바탕으로 정리한 것이며, 실제 구현 시에는 사용하는 MCU의 라이브러리(FOC SDK 등) 문서를 참고해야 한다.

---

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
